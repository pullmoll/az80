DCBIO	EQU	13H	; DCB input
KEYHIT	EQU	2BH
INPUT	EQU	40H
INKEY	EQU	49H
SLEEP	EQU	60H
RESET	EQU	66H
BASRET	EQU	10FH
BASCLS	EQU	1C9H
OUTCH	EQU	32AH	; OUTPUT CHARACTER TO SCREEN
HLDEC	EQU	0FAFH	; PRINT HL AS DECIMAL
RAM	EQU	4000H	; RAM START
RST30V	EQU	400FH
CURSOR	EQU	4020H

COLOUR	EQU	4023H	; BASIC COLOUR
COLWHT	EQU	0
COLRED	EQU	2
COLYEL	EQU	3
COLORG	EQU	4

TIMES	EQU	4041H
TIMEM	EQU	4042H
TIMEH	EQU	4043H
SPSAVE	EQU	40A0H
POS	EQU	40A6H
CMDVEC	EQU	41ADH	; COMMAND LOOP VECTOR
INPUTB	EQU	41E8H
FKEY	EQU	4350H	; FUNCTION KEY DEFINITIONS
MYSP	EQU	43A0H
CMDPTR	EQU	43A2H	; POINTER TO COMMAND BUFFER
CURDRV	EQU	43A4H	; CURRENT DRIVE NUMBER
DSTDRV	EQU	43A5H
GRAMAX	EQU	43A6H
GRACNT	EQU	43A8H
FILCNT	EQU	43AAH
DOSERR	EQU	43ACH
FLAGQ	EQU	43ADH
MESGQ	EQU	43AEH
CALLQ	EQU	43B0H
MEM0	EQU	4800H	; 4800-4BFF BUFFER 0 (2K)
MEM0H	EQU	5000H
MEM1	EQU	5000H	; 4C00-57FF BUFFER 1 (2K = 8sec)
MEM1H	EQU	5800H
DOSBUF	EQU	5800H	; 5800-???? DOS BUFFER
PDRIVE0	EQU	5A71H
MEM2	EQU	5C00H	; 5C00-C000 BUFFER 2 (25K = 100sec)
MEM2H	EQU	0C000H
MEM3	EQU	0F400H	; F400-F800 BUFFER 3 (1K = 4sec)
MEM3H	EQU	0F800H
DOSBH	EQU	59H
DOSDRV	EQU	5A08H	; DOS DRIVE NUMBER
PD_DDSL	EQU	5A0AH	; GRANULE NUMBER OF DIRECTORY
PD_DDGL	EQU	5A0BH	; GRANULE LENGTH
PD_DDGA	EQU	5A0FH	; GRANULE BITMASK LENGTH
PD_SPG	EQU	5A12H	; SECTORS PER GRANULE
DDTA1	EQU	5B48H	; DISK TRANSIENT AREA 1
DDTA2	EQU	5B68H	; DISK TRANSIENT AREA 2
CMD	EQU	0C319H
CMDLOOP	EQU	0C977H	; CGDOS ROM COMMAND LOOP
CREATE	EQU	0CE20H
OPEN	EQU	0CE24H
CLOSE	EQU	0CE28H
KILL	EQU	0CE2CH
GET	EQU	0CE36H
PUT	EQU	0CE39H
DRVSEL	EQU	0CE5BH
GETP	EQU	0CF6FH	; GET PROTECTED SECTOR
PUTP	EQU	0CF7BH	; PUT PROTECTED SECTOR

	ORG	0E000H
	DEFM	"N"

ENTRY	LD	A,15
	CALL	OUTCH
	LD	HL,RAM
ENTRY1	INC	H
	LD	A,H
	OR	A
	JR	Z,ENTRY2
	LD	A,(HL)
	LD	B,A
	CPL
	LD	(HL),A
	CP	(HL)
	LD	(HL),B
	JR	Z,ENTRY1
	DEC	H
ENTRY2	DEC	HL
	LD	DE,-50
	LD	(40B1H),HL
	ADD	HL,DE
	LD	(SPSAVE),HL
	CALL	1B4DH
	CALL	BASCLS
	LD	A,COLWHT
	LD	(COLOUR),A
	LD	HL,SIGNON
	CALL	PRINT

START	LD	HL,FKEASY
	LD	DE,FKEY
	LD	BC,4*7
	LDIR
	LD	A,0C3H
	LD	(RST30V),A
	LD	HL,START
	LD	(RST30V+1),HL
	LD	HL,CMDDOS
	LD	(CMDVEC),HL
	JP	START1

SIGNON	DEFM	"*****************************",13
	DEFM	"* Easy Colour DOS extension *",13
	DEFM	"*****************************",13
	DEFM	"(C) 1985 by C.Poetzsch",13,0

FKEASY	DEFM	"HELP	"
	DEFM	"DIR	"
	DEFM	"SCOPY 3"
	DEFM	"BASIC	"

FKBASIC DEFM	"LIST	"
	DEFM	"RUN	"
	DEFM	"AUTO	"
	DEFM	"EDIT	"

EBOOT	DEFM	"BOOT"
ECMD	DEFM	"/CMD",0

ARGS	DEFB	128
	DEFM	"(change drive",')'+128
	DEFM	"(current drive",')'+128
	DEFM	"0-",'3'+128
	DEFM	"[0-3",']'+128
	DEFM	"name[/ext[:#]",']'+128
	DEFM	"src[/ext[:#] dst[/ext[:#]",']'+128
	DEFM	"name[ date",']'+128

A0	EQU	0
A1	EQU	1
A2	EQU	2
ADRIVE	EQU	3
ADRIVEO	EQU	4
ANAME	EQU	5
ASRCDST	EQU	6
ANAMDAT	EQU	7

CMDS	DEFB	'0'+128
	DEFW	DRIVE
	DEFB	A1

	DEFB	'1'+128
	DEFW	DRIVE
	DEFB	A1

	DEFB	'2'+128
	DEFW	DRIVE
	DEFB	A1

	DEFB	'3'+128
	DEFW	DRIVE
	DEFB	A1

	DEFM	"BASI",'C'+128
	DEFW	BASIC
	DEFB	A0

	DEFM	"CL",'S'+128
	DEFW	CLS
	DEFB	A0

	DEFM	"COP",'Y'+128
	DEFW	COPY
	DEFB	ASRCDST

	DEFM	"DE",'L'+128
	DEFW	ERA
	DEFB	ANAME

	DEFM	"DI",'R'+128
	DEFW	DIR
	DEFB	ADRIVEO

	DEFM	"ER",'A'+128
	DEFW	ERA
	DEFB	ANAME

	DEFM	"HEL",'P'+128
	DEFW	HELP
	DEFB	A0

	DEFM	"NAM",'E'+128
	DEFW	NAME
	DEFB	ANAMDAT

	DEFM	"PDRIV",'E'+128
	DEFW	PDRIVE
	DEFB	ADRIVEO

	DEFM	"PURG",'E'+128
	DEFW	PURGE
	DEFB	A2

	DEFM	"QCOP",'Y'+128
	DEFW	QCOPY
	DEFB	ADRIVE

	DEFM	"RE",'M'+128
	DEFW	RESET
	DEFB	A0

	DEFM	"RE",'N'+128
	DEFW	REN
	DEFB	ASRCDST

	DEFM	"TIM",'E'+128
	DEFW	TIME
	DEFB	A0

	DEFM	"TYP",'E'+128
	DEFW	TYPE
	DEFB	ANAME

	DEFM	"VIE",'W'+128
	DEFW	VIEW
	DEFB	ANAME

	DEFM	"XDI",'R'+128
	DEFW	DIR
	DEFB	ADRIVEO

	DEFB	255
	DEFB	0

MCOPY	DEFM	" Copy (Y/N/A/Break) ",0
MKILL	DEFM	" Kill (Y/N/A/Break) ",0
MSECTS	DEFM	" sectors",13,0
MLOAD	DEFM	"reading ",0
MSAVE	DEFM	"writing ",0
MERASE	DEFM	"erasing ",0
MTIME	DEFM	"New time (HH:MM:SS) : ",0
MLABEL	DEFM	"Label: ",0
MDATE	DEFM	"	Date: ",0
MKBIN	DEFM	" KB in ",0
MFILES	DEFM	" File(s)",13,0
MTOTAL	DEFM	" KB total, ",0
MFREE	DEFM	" KB free",0

MFROM	DEFM	"block : ",0
MFILL	DEFM	"filler: ",0
MENTRY	DEFM	"entry : ",0

MMEM	DEFM	"out of memory",0
MDNUM	DEFM	"bad drive #",0
MDRV	DEFM	"missing drive #",0
MFILE	DEFM	"file not found",0
MBIN	DEFM	"bad bin format",0

MPDRIVE	EQU	$
MTC	DEFM	"T",'C'+128
	DEFB	3
MSPT	DEFM	"SP",'T'+128
	DEFB	4
MTSR	DEFM	"TS",'R'+128
	DEFB	2
MGPL	DEFM	"GP",'L'+128
	DEFB	5
MDDSL	DEFM	"DDS",'L'+128
	DEFB	0
MDDGA	DEFM	"DDG",'A'+128
	DEFB	9
MGATL	DEFM	"GAT",'L'+128
	DEFB	1
MFL	DEFM	"F",'L'+128
	DEFB	7
MSPG	DEFM	"SP",'G'+128
	DEFB	8
MS0	DEFM	"S",'0'+128
	DEFB	6
	DEFB	0FFH

START1	LD	HL,CMDPTR
	LD	DE,CMDPTR+1
	LD	BC,40
	LD	(HL),0
	LDIR
	LD	HL,EBOOT
	LD	DE,DDTA1
	LD	BC,9
	LDIR
	CALL	RUNCMD
	JP	RESET

CMDDOS	CALL	2169H
	CALL	0CA5EH
	CALL	1BAFH
	LD	HL,INPUTB
	LD	DE,INPUTB+1
	LD	BC,39
	LD	(HL),0
	LDIR
	JP	PROMPT

DRIVE	LD	A,(INPUTB)
	AND	3
	LD	(CURDRV),A

PROMPT	LD	SP,INPUTB+250
	CALL	PRTCR
	LD	A,(CURDRV)
	CALL	DRVSEL
	LD	A,(DOSDRV)
	ADD	A,'0'
	CALL	OUTCH
	LD	A,'>'
	CALL	OUTCH
	LD	HL,INPUTB
	LD	B,38
	CALL	INPUT
	JR	C,PROMPT
	LD	A,B
	OR	A
	JR	Z,PROMPT
	LD	IY,CMDS
	LD	IX,INPUTB
	CALL	FCMD
	CP	-1
	JR	Z,NOTINT
	JP	(HL)

NOTINT	LD	HL,INPUTB
	LD	DE,DDTA1
CPYDTA	LD	A,(HL)
	LD	(DE),A
	INC	HL
	INC	DE
	DJNZ	CPYDTA
	LD	(CMDPTR),DE
	CALL	APPCMD		; APPEND "/CMD",0 TO COMMAND
	CALL	RUNCMD		; TRY TO RUN COMMAND FILE
	JP	C,ENDCMD
	JP	RESET

CLS	CALL	BASCLS
	JP	RESET

HELP	LD	HL,CMDS
HELP1	LD	B,8
HELP2	LD	A,(HL)
	INC	HL
	BIT	7,A
	JR	NZ,HELP3
	CALL	OUTCH
	DJNZ	HELP2
HELP3	AND	127
	CALL	OUTCH
	DEC	B
HELP4	CALL	PRTSPC
	DJNZ	HELP4
	INC	HL		; SKIP COMMAND ENTRY
	INC	HL
	LD	A,(HL)		; GET ARGUMENT FLAGS
	INC	HL
	CALL	ARGF
	LD	A,(HL)
	CP	0FFH		; END OF TABLE?
	JR	NZ,HELP1	; NO, LIST MORE
	JP	ENDCMD

ARGF	PUSH	HL
	LD	HL,ARGS
	INC	A
ARGF1	DEC	A
	JR	Z,ARGF3
ARGF2	BIT	7,(HL)
	INC	HL
	JR	Z,ARGF2
	JR	ARGF1
ARGF3	LD	A,(HL)
	INC	HL
	BIT	7,A
	JR	NZ,ARGF4
	CALL	OUTCH
	JR	ARGF3
ARGF4	AND	127
	CALL	OUTCH
	LD	A,13
	CALL	OUTCH
	POP	HL
	RET

NAME	PUSH	IX
	LD	A,(CURDRV)
	CALL	DRVSEL
	LD	HL,DOSBUF
	CALL	SNOGAT
	LD	B,0
	CALL	GETP
	LD	B,8
	POP	HL
	LD	DE,DOSBUF+208

CNAME	LD	A,(HL)
	LD	(DE),A
	CP	' '
	JR	Z,FNAME
	INC	DE
	INC	HL
	DJNZ	CNAME
	JR	FNAME1

FNAME	LD	(DE),A
	INC	DE
	DJNZ	FNAME

FNAME1	INC	HL
	LD	DE,DOSBUF+216

CDATE	LD	A,(HL)
	CP	13
	JR	Z,FDATE
	LD	(DE),A
	INC	DE
	INC	HL
	DJNZ	CDATE
	JR	FDATE1

FDATE	LD	A,' '
	LD	(DE),A
	INC	DE
	DJNZ	FDATE

FDATE1	LD	HL,DOSBUF
	CALL	SNOGAT
	LD	B,0
	CALL	PUTP
	JP	RESET

DSTDE	PUSH	BC
	PUSH	HL
	PUSH	AF
	LD	HL,DOSBUF
	LD	BC,256
	LDIR
	LD	A,D
	CP	MEM1H/256
	JR	NZ,DSTDE1
	LD	DE,MEM2
DSTDE1	CP	MEM2H/256
	JR	NZ,DSTDE2
	LD	DE,MEM3
DSTDE2	CP	MEM3H/256
	JP	NC,ERRMEM
	POP	AF
	POP	HL
	POP	BC
	RET

SRCHL	PUSH	BC
	PUSH	DE
	PUSH	AF
	LD	DE,DOSBUF
	LD	BC,256
	LDIR
	LD	A,H
	CP	MEM1H/256
	JR	NZ,SRCHL1
	LD	HL,MEM2
SRCHL1	CP	MEM2H/256
	JR	NZ,SRCHL2
	LD	HL,MEM3
SRCHL2	CP	MEM3H/256
	JP	NC,ERRMEM
	POP	AF
	POP	DE
	POP	BC
	RET


COPY	PUSH	IX
	POP	HL
	LD	BC,0

COPY0	LD	A,(HL)
	INC	HL
	INC	C
	CP	13
	JP	Z,ERRDRV
	CP	' '
	JR	NZ,COPY0
	LD	A,(HL)
	CP	'0'
	JP	C,ERRDRV
	CP	'4'
	JP	NC,ERRDRV
	AND	3
	LD	(DSTDRV),A

COPY1	DEC	HL
	LD	(HL),0
	LD	HL,INPUTB+5
	LD	DE,DDTA1
	LDIR
	LD	DE,MEM1
	EXX
	LD	DE,DDTA1
	LD	HL,DOSBUF
	LD	B,0
	CALL	OPEN
	JP	NZ,ENDCMD

COPY2	LD	DE,DDTA1
	CALL	GET
	JR	NZ,COPY3
	EXX
	CALL	DSTDE
	EXX
	JP	C,ERRMEM
	JR	COPY2

COPY3	CP	28
	JR	Z,COPY4
	CP	29
	JR	Z,COPY4
	JP	ENDCMD

COPY4	PUSH	IX
	POP	HL
	LD	DE,DDTA1
COPY5	LD	A,(HL)
	INC	HL
	LD	(DE),A
	INC	DE
	CP	':'
	JR	Z,COPY6
	OR	A
	JR	NZ,COPY5
COPY6	DEC	DE
	LD	A,':'
	LD	(DE),A
	INC	DE
	LD	A,(DSTDRV)
	ADD	A,'0'
	LD	(DE),A
	INC	DE
	XOR	A
	LD	(DE),A
	LD	HL,DOSBUF
	LD	DE,DDTA1
	LD	B,0
	CALL	CREATE
	JP	NZ,ENDCMD
	EXX
	PUSH	DE
	LD	HL,MEM1
	EXX
	POP	HL

COPY7	EXX
	CALL	SRCHL
	PUSH	HL
	EXX
	LD	DE,DDTA1
	CALL	PUT
	JP	NZ,ENDCMD
	POP	DE
	OR	A
	PUSH	HL
	SBC	HL,DE
	POP	HL
	JR	NZ,COPY7
	LD	DE,DDTA1
	CALL	CLOSE
	JP	NZ,ENDCMD
	JP	RESET

TIME	LD	HL,MTIME
	CALL	PRINT
	LD	HL,INPUTB+1
	LD	B,8
	CALL	INPUT
	LD	HL,INPUTB
	LD	(HL),20H
	CALL	2B1BH
	LD	(TIMEH),A
	LD	HL,(INPUTB+4)
	LD	(INPUTB+1),HL
	LD	HL,INPUTB
	CALL	2B1BH
	LD	(TIMEM),A
	LD	HL,(INPUTB+7)
	LD	(INPUTB+1),HL
	LD	HL,INPUTB
	CALL	2B1BH
	LD	(TIMES),A
	LD	L,'U'
	LD	H,0
	LD	(INPUTB),HL
	LD	HL,INPUTB
	LD	A,'U'
	CALL	CMD
	JP	RESET

DIR	LD	A,(IX)
	CP	13
	JR	Z,DIR0
	CP	'0'
	JP	C,ERRDIR
	CP	'4'
	JP	NC,ERRDIR
	AND	3
	CALL	DRVSEL

DIR0	LD	HL,0
	LD	(FILCNT),HL
	LD	HL,DOSBUF
	CALL	SNOGAT
	LD	B,0
	CALL	GETP
	CALL	CGRANS
	LD	IX,COLOUR
	LD	(IX),COLRED
	LD	HL,MLABEL
	CALL	PRINT
	LD	(IX),COLORG
	LD	HL,DOSBUF+208	; disk name in GAT sector
	CALL	PRINT8
	LD	(IX),COLRED
	LD	HL,MDATE
	CALL	PRINT
	LD	(IX),COLORG
	LD	HL,DOSBUF+216	; disk date in GAT sector
	CALL	PRINT8
	CALL	PRTCR
	LD	(IX),COLWHT

	CALL	SNODIR

DIR3	LD	HL,DOSBUF
	CALL	GETP
	JR	Z,DIRX
	CALL	DIRS
	INC	DE
	JR	DIR3

DIRX	CALL	NEWLIN
	LD	(IX),COLRED
	LD	HL,(GRACNT)
	CALL	PRTKB
	LD	(IX),COLORG
	LD	HL,MKBIN
	CALL	PRINT
	LD	(IX),COLRED
	LD	HL,(FILCNT)
	CALL	HLDEC
	LD	(IX),COLORG
	LD	HL,MFILES
	CALL	PRINT
	LD	(IX),COLRED
	LD	HL,(GRAMAX)
	CALL	PRTKB
	LD	(IX),COLORG
	LD	HL,MTOTAL
	CALL	PRINT
	LD	(IX),COLRED
	LD	HL,(GRAMAX)
	LD	DE,(GRACNT)
	OR	A
	SBC	HL,DE
	CALL	PRTKB
	LD	(IX),COLORG
	LD	HL,MFREE
	CALL	PRINT
	LD	(IX),COLWHT
	JP	RESET

DIRS	PUSH	BC
	PUSH	DE
	LD	HL,DOSBUF
	LD	B,8		; dir entries per sector

DIRS1	LD	A,(HL)
	CP	16
	JR	Z,DIRS2
	AND	16
	CP	16
	JR	NZ,DIRSX
	LD	A,(INPUTB)
	CP	'X'
	JR	NZ,DIRSX
	LD	A,COLYEL
	LD	(COLOUR),A
DIRS2	PUSH	HL
	LD	DE,(FILCNT)
	INC	DE
	LD	(FILCNT),DE
	LD	DE,5
	ADD	HL,DE
	PUSH	BC
	CALL	PRINT8
	CALL	PRTSPC
	CALL	PRINT3
	CALL	PRTSPC
	LD	A,(POS)
	CP	38		; extra space in column 38?
	CALL	NC,PRTSPC	; yes, print it
	POP	BC
	POP	HL
DIRSX	LD	A,COLWHT
	LD	(COLOUR),A
	LD	DE,32
	ADD	HL,DE
	DJNZ	DIRS1
	POP	DE
	POP	BC
	RET

PUTCHR	LD	(IX),A
	INC	IX
	CALL	OUTCH
	RET

; QLIST - list files from current drive
; and interactively select an action to
; be taken on them
QLIST	CALL	NEWLIN
	LD	A,0
	LD	(FLAGQ),A
	LD	A,(CURDRV)
	CALL	DRVSEL
	LD	IX,MEM0		; store filenames in MEM0
	CALL	SNODIR

; next directory sector
QLIST1	LD	HL,DOSBUF
	CALL	GETP
	OR	A
	JP	Z,QLISTX	; end of directory

; next directory entry
QLIST2	PUSH	DE
	PUSH	HL
	LD	A,(HL)
	CP	16
	JP	NZ,QLISTC	; not a regular file
	LD	DE,5
	ADD	HL,DE		; skip to name
	LD	IY,(CURSOR)
	LD	B,8		; copy at most 8 characters
QLIST3	LD	A,(HL)
	CP	' '
	JR	Z,QLIST4	; stop at first blank
	CALL	PUTCHR
	INC	HL
	DJNZ	QLIST3
QLIST4	LD	A,L		; skip over blanks in filename
	ADD	A,B
	LD	L,A
	LD	A,0
	ADC	A,H
	LD	H,A
	LD	A,(HL)		; check extension
	CP	' '		; no extension?
	JR	Z,QLIST6	; skip appending
	LD	A,'/'		; append a slash
	CALL	PUTCHR
	LD	B,3		; and at most 3 characters
QLIST5	LD	A,(HL)
	CP	' '		; end of extension?
	JR	Z,QLIST6	; done appending
	CALL	PUTCHR
	INC	HL
	DJNZ	QLIST5
QLIST6	LD	A,':'		; append colon
	CALL	PUTCHR
	LD	A,(DOSDRV)	; append drive as '0' to '3'
	ADD	A,'0'
	CALL	PUTCHR
	LD	BC,16		; jump to screen column 16
	ADD	IY,BC
	LD	(CURSOR),IY
	LD	HL,(MESGQ)	; ask questions
	CALL	PRINT
	LD	A,14		; cursor on
	CALL	OUTCH
	LD	A,(FLAGQ)	; preset answer
	OR	A
	CALL	Z,INKEY		; none, wait for key
	CALL	OUTCH
	CP	1		; hit break (no more)
	JR	Z,QLIST8
	CP	'A'		; hit 'A' for 'all'?
	JR	Z,QLIST9	; set all
	CP	'Y'		; hit 'Y' for 'yes'
	LD	A,0		; use flag 0
	JR	Z,QLISTA	; if yes
	INC	A		; else flag 1
	JR	QLISTA		; store in buffer
QLIST8	LD	A,'N'		; answer 'N' to all following
	LD	(FLAGQ),A
	LD	A,1		; store 1s as flags
	JR	QLISTA
QLIST9	LD	A,'Y'		; answer 'Y' to all following
	LD	(FLAGQ),A
	LD	A,0		; store 0s as flags
QLISTA	LD	(IX),A		; store flag
	INC	IX
	CALL	PRTCR

; next directory entry
QLISTC	POP	HL		; get back buffer
	POP	DE		; get back sector
	LD	BC,32		; next entry in sector
	ADD	HL,BC
	LD	A,H		; address hi
	CP	DOSBH		; buffer end reached?
	JP	NZ,QLIST2	; no, next entry
	INC	DE		; next sector
	JP	QLIST1

QLISTX	CALL	PRTCR		; another CR
	LD	(IX),13		; terminate buffer
; TODO: should check that IX didn't overrun
; MEM0 to MEM0H (ideally inside the loop)
	LD	IX,MEM0		; start at MEM0
	PUSH	IX

QEXEC	POP	IX		; get filename pointer
	LD	A,(IX)		; get character
	CP	13		; end of list?
	JP	Z,RESET		; jump to command line
	LD	DE,DDTA2	; copy name to DDTA2
QEXEC1	LD	A,(IX)
	LD	(DE),A
	INC	DE
	INC	IX
	CP	' '
	JR	NC,QEXEC1	; until flag is found
	PUSH	IX		; put filename pointer
	CP	1		; marked as skip?
	JR	Z,QEXEC		; next entry
	PUSH	DE		; save end of name pointer
	LD	HL,DDTA2	; copy DDTA2
	LD	DE,DDTA1	; to DDTA1
	LD	BC,32		; 32 bytes
	LDIR
	LD	A,(DSTDRV)	; get destination drive
	ADD	A,'0'		; make it '0' to '3'
	POP	DE		; get back end of name pointer
	DEC	DE		; go back 2 characters
	DEC	DE
	LD	(DE),A		; replace drive #
	LD	HL,QEXEC	; return address
	PUSH	HL
	LD	HL,(CALLQ)	; enumerator callback
	JP	(HL)

; QCOPY - quick copy some (a lot) of files
; from the current disk to destination
QCOPY	LD	A,(IX)
	CP	'0'
	JP	C,ERRDRV
	CP	'4'
	JP	NC,ERRDRV
	AND	3
	LD	(DSTDRV),A
	LD	HL,MCOPY	; set enumerator message
	LD	(MESGQ),HL
	LD	HL,QCOPY1	; set enumerator callback
	LD	(CALLQ),HL
	JP	QLIST

QCOPY1	LD	HL,MLOAD
	CALL	PRINT
	LD	HL,DDTA1
	CALL	PRINT

	LD	HL,DOSBUF	; open DDTA1 with DOSBUF
	LD	DE,DDTA1
	LD	BC,32		; open existing
	CALL	OPEN
	LD	DE,MEM1		; copy to MEM1...

QCOPY2	PUSH	DE		; save dest buffer
	LD	DE,DDTA1	; get DDTA1 sector
	CALL	GET
	POP	DE
	OR	A
	JR	NZ,QCOPY3	; error (end of file)
	CALL	DSTDE		; copy DOSBUFF to (DE++)
	INC	B		; sector count
	JR	QCOPY2

QCOPY3	PUSH	BC		; save sector count
	LD	DE,DDTA1	; close DDTA1
	CALL	CLOSE
	CALL	PRTSPC
	LD	L,B		; print number of sectors
	LD	H,0
	CALL	HLDEC
	LD	HL,MSECTS	; and reading message
	CALL	PRINT

	LD	HL,DDTA2	; copy DDTA2
	LD	DE,DDTA1	; to DDTA1
	LD	BC,32
	LDIR
	LD	HL,MSAVE	; print writing message
	CALL	PRINT
	LD	HL,DDTA1	; print filename
	CALL	PRINT
	CALL	PRTCR
	LD	HL,DOSBUF	; open DDTA1 with DOSBUF
	LD	DE,DDTA1
	LD	BC,0		; create file
	CALL	CREATE
	POP	BC		; get back sector count
	INC	B		; empty file (0 sectors)?
	DEC	B
	JR	Z,QCOPY5	; yes, just close
	LD	HL,MEM1		; copy from MEM1 ...
QCOPY4	PUSH	BC		; save sector count
	CALL	SRCHL		; copy (HL++) to DOSBUFF
	LD	DE,DDTA1
	CALL	PUT
	POP	BC
	DJNZ	QCOPY4
QCOPY5	LD	DE,DDTA1
	CALL	CLOSE
	RET

; PURGE - select from a list of files
; on the current drive to delete
PURGE	LD	HL,MKILL	; "Kill (Y/N/A/Break)"
	LD	(MESGQ),HL
	LD	HL,PURGE1	; The enumerator function
	LD	(CALLQ),HL
	JP	QLIST

PURGE1	LD	HL,MERASE
	CALL	PRINT
	LD	HL,DDTA1	; print filename
	CALL	PRINT
	LD	DE,DDTA1	; open DDTA1
	LD	BC,0		; create
	CALL	OPEN
	RET	NZ
	LD	DE,DDTA1
	CALL	KILL		; kill file
	CALL	PRTCR
	RET

; PURGE - select from a list of files
; on the current drive to delete
TYPE	PUSH	IX
	POP	HL
	LD	DE,DDTA1
	LD	A,B
	SUB	5		; "TYPE " is 5 characters
	LD	C,A
	XOR	A
	LD	B,A
	LDIR
	LD	(DE),A		; 0 terminate filename
	LD	DE,DDTA1	; open file DDTA1 using DOSBUF
	LD	HL,DOSBUF
	CALL	OPEN
	JP	NZ,ENDCMD	; error opening file?

TYPE1	LD	HL,DOSBUF
	LD	DE,DDTA1
	LD	B,0
	CALL	DCBIO
	JR	NZ,TYPE2	; end of file?
	CALL	OUTCH
	CALL	KEYHIT
	CP	1		; user hit Break?
	JP	Z,RESET
	CP	32		; user hit Space?
	CALL	Z,INKEY
	LD	BC,100		; sleep 100 * 11.6us
	CALL	SLEEP
	JR	TYPE1

TYPE2	CP	28		; END OF FILE?
	JP	NZ,ENDCMD
	JP	RESET

REN	LD	HL,INPUTB+2
	LD	A,'N'		; DOS COMMAND: CMD"N...
	CALL	CMD
	JP	NZ,ENDCMD
	JP	RESET

ERA	PUSH	IX
	POP	HL
	LD	DE,DDTA1

ERA1	LD	A,(HL)
	LD	(DE),A
	INC	HL
	INC	DE
	CP	13
	JR	NZ,ERA1
	DEC	DE
	XOR	A
	LD	(DE),A
	LD	HL,DOSBUF
	LD	DE,DDTA1
	LD	B,0
	CALL	OPEN
	JP	NZ,ENDCMD
	LD	DE,DDTA1
	CALL	KILL
	JP	RESET

BASIC	LD	HL,FKBASIC
	LD	DE,FKEY
	LD	BC,4*7
	LDIR
	LD	HL,CMDLOOP
	LD	(CMDVEC),HL
	LD	SP,(SPSAVE)
	CALL	BASCLS
	JP	BASRET		; RETURN TO BASIC

INFIL	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	HL,(CMDPTR)
	LD	C,(HL)
	INC	HL
	LD	A,H
	CP	DOSBH
	JR	NZ,INFIL1
	LD	DE,DDTA1
	CALL	GET
	LD	HL,DOSBUF
INFIL1	LD	(CMDPTR),HL
	LD	A,C
	POP	HL
	POP	DE
	POP	BC
	RET

RUNCMD	PUSH	BC
	PUSH	DE
	PUSH	HL
	PUSH	AF
	LD	HL,DOSBUF
	LD	DE,DDTA1
	LD	(CMDPTR),HL
	CALL	OPEN
	OR	A
	JR	NZ,RUNX
	CALL	GET
	JR	RUN1
RUNIGN	CALL	INFIL
	LD	B,A
RUN0	CALL	INFIL
	DJNZ	RUN0
RUN1	CALL	INFIL
	CP	3
	JR	Z,RUNIGN
	CP	2
	JR	Z,RUNRUN
	CP	1
	JP	NZ,ERRBIN
	CALL	INFIL
	SUB	2
	LD	B,A
	CALL	INFIL
	LD	L,A
	CALL	INFIL
	LD	H,A
RUN2	CALL	INFIL
	LD	(HL),A
	INC	HL
	DJNZ	RUN2
	JR	RUN1
RUNX	POP	AF
	SCF
	POP	HL
	POP	DE
	POP	BC
	JR	RUNR1

RUNRUN	CALL	INFIL
	CALL	INFIL
	LD	L,A
	CALL	INFIL
	LD	H,A
	LD	(CMDPTR),HL
	POP	AF
	OR	A
	POP	HL
	POP	DE
	POP	BC
RUNR1	JR	C,FCMD
	PUSH	HL
	LD	HL,(CMDPTR)
	EX	(SP),HL
	RET

FCMD	LD	(CMDPTR),IX
FCMD1	LD	A,(IY)
	CP	0FFH
	RET	Z
	RES	7,A
	CP	(IX)
	JR	NZ,FCMD3
	BIT	7,(IY)
	JR	NZ,FCMD2
	INC	IY
	INC	IX
	JR	FCMD1
FCMD2	INC	IX
	LD	A,(IX)
	CP	' '
	JR	Z,FCMD2
	LD	L,(IY+1)
	LD	H,(IY+2)
	RET
FCMD3	LD	IX,(CMDPTR)
FCMD4	BIT	7,(IY)
	INC	IY
	JR	Z,FCMD4
	INC	IY	; SKIP ENTRY + ARGUMENT FLAGS
	INC	IY
	INC	IY
	JR	FCMD1

VIEW	PUSH	IX
	POP	HL
	LD	DE,DDTA1
	LD	A,B
	SUB	5
	LD	C,A
	XOR	A
	LD	B,A
	LDIR
	LD	(DE),A
	LD	HL,DOSBUF
	LD	DE,DDTA1
	CALL	OPEN
	JP	NZ,ENDCMD
	LD	HL,DOSBUF
	LD	DE,DDTA1
	LD	(CMDPTR),HL
	CALL	GET
VIEW0	LD	IX,0
	LD	IY,0
VIEW1	CALL	INFIL
	CP	3
	JR	Z,VIEWF
	CP	2
	JR	Z,VIEWX
	CP	1
	JP	NZ,ERRBIN
	CALL	INFIL
	LD	B,A
	CALL	INFIL
	LD	E,A
	DEC	B
	CALL	INFIL
	LD	D,A
	DEC	B
	PUSH	IX
	POP	HL
	OR	A
	SBC	HL,DE
	JR	Z,VIEW3
	CALL	VIEWE
VIEW2	PUSH	DE
	PUSH	DE
	POP	IX
	POP	IY
	LD	HL,MFROM
	CALL	PRINT
	EX	DE,HL
	CALL	HEXHL
	LD	A,'-'
	CALL	OUTCH
VIEW3	CALL	INFIL
	INC	IX
	INC	IY
	DJNZ	VIEW3
	JR	VIEW1

VIEWF	CALL	VIEWE
	LD	HL,MFILL
	CALL	PRINT
	CALL	INFIL
	LD	B,A
	CALL	HEXA
	CALL	PRTCR
VIEWF1	CALL	INFIL
	DJNZ	VIEWF1
	JR	VIEW0

VIEWX	CALL	VIEWE
VIEWX1	CALL	INFIL
	LD	B,A
	CALL	INFIL
	LD	E,A
	CALL	INFIL
	LD	D,A
	LD	HL,MENTRY
	CALL	PRINT
	EX	DE,HL
	CALL	HEXHL
	LD	DE,DDTA1
	CALL	CLOSE
	JP	RESET

VIEWE	PUSH	IY
	POP	HL
	LD	A,H
	OR	L
	RET	Z
	DEC	HL
	CALL	HEXHL
	CALL	PRTCR
	RET

HEXHL	LD	A,H
	CALL	HEXA
	LD	A,L
HEXA	PUSH	AF
	RRCA
	RRCA
	RRCA
	RRCA
	CALL	NIBBLE
	POP	AF
NIBBLE	AND	15
	ADD	A,90H
	DAA
	ADC	A,40H
	DAA
	JP	OUTCH

NEWLIN	LD	A,(POS)
	OR	A
	CALL	NZ,PRTCR
	RET

ERRMEM	LD	HL,MMEM
PRINTX	CALL	NEWLIN
	CALL	PRINT
ENDCMD	JP	RESET

ERRDIR	LD	HL,MDNUM
	JR	PRINTX

ERRDRV	LD	HL,MDRV
	JR	PRINTX

ERRFIL	LD	HL,MFILE
	JR	PRINTX

ERRBIN	LD	HL,MBIN
	JR	PRINTX

PRTCR	LD	A,13
	JP	OUTCH

PRTSPC	LD	A,32
	JP	OUTCH

PRINT	LD	A,(HL)
	INC	HL
	OR	A
	RET	Z
	CALL	OUTCH
	JR	PRINT

PRINT3	LD	B,3
	JR	PRINTB
PRINT8	LD	B,8
PRINTB	LD	A,(HL)
	INC	HL
	CALL	OUTCH
	DJNZ	PRINTB
	RET

APPCMD	LD	HL,ECMD
	LD	BC,5
	LDIR
	RET

; CGRANS - count used and total granules
; int the GAT (granule allocation table)
; that was read into DOSBUF
CGRANS	LD	IX,DOSBUF
	LD	HL,0
	LD	DE,0
	LD	A,(PD_DDGL)
	LD	B,A
CGRAN1	PUSH	BC
	LD	A,(PD_DDGA)
	LD	B,A
	LD	A,(IX)
	INC	IX
CGRAN2	RRCA
	JR	NC,CGRAN3
	INC	DE
CGRAN3	INC	HL
	DJNZ	CGRAN2
	POP	BC
	DJNZ	CGRAN1
	LD	(GRACNT),DE
	LD	(GRAMAX),HL
	RET

; PRTKB - print the number in HL as kilo bytes
; multiply HL by number of sectors per granule,
; then divide by four (we have 256 byte sectors)
PRTKB	LD	DE,0
	LD	A,(PD_SPG)
	LD	B,A
	EX	DE,HL
	XOR	A
PRTKB1	ADD	HL,DE	; add number of granules
	ADC	A,0	; add carry to A
	DJNZ	PRTKB1	; repeat PD_SPG times
	SRL	A	; divide AHL by 2
	RR	H
	RR	L
	SRL	A	; divide AHL by 2
	RR	H
	RR	L
	CALL	HLDEC	; print as decimal
	RET

; SNOGAT - calculate the sector number
; of the GAT (granule allocation table)
SNOGAT	PUSH	HL
	PUSH	AF
	LD	A,(PD_SPG)	; sectors per granule
	LD	B,A
	LD	A,(PD_DDGA)	; disk directory granule allocation
	LD	E,A
	LD	D,0
	LD	HL,0
; primitive multiply by addition: PD_SPG * PD_DDGA
SNOG1	ADD	HL,DE
	DJNZ	SNOG1
	LD	A,(PD_DDSL)	; start location of directory
	LD	B,A
	LD	DE,0
	EX	DE,HL
; primitive multiply by addition: PD_DDSL * PD_SPG * PD_DDGA
SNOG2	ADD	HL,DE
	DJNZ	SNOG2
	EX	DE,HL		; result to DE
	POP	AF
	POP	HL
	RET

; CALCULATE THE SECTOR NUMBER OF THE
; FIRST DIRECTORY SECTOR
SNODIR	CALL	SNOGAT
	INC	DE		; directory always begins
	INC	DE		; two sectors after GAT
	RET

PDRIVE	LD	A,(IX)
	CP	13
	LD	A,(CURDRV)
	JR	Z,PDRIVE1
	CP	'0'
	JP	C,ERRDRV
	CP	'4'
	JP	NC,ERRDRV
PDRIVE1	AND	3
	LD	BC,PDRIVE0
	LD	L,A		; HL = A * 10
	ADD	A,A
	ADD	A,A
	ADD	A,L
	ADD	A,A
	LD	L,A
	LD	H,0
	ADD	HL,BC		; HL = PDRIVEx
	PUSH	HL
	POP	IY
	LD	IX,MPDRIVE
PDRIVE2	LD	A,(IX)
	INC	IX
	BIT	7,A
	JR	NZ,PDRIVE3
	CALL	OUTCH
	JR	PDRIVE2
PDRIVE3	AND	127
	CALL	OUTCH
	LD	A,':'
	CALL	OUTCH
	LD	C,(IX)
	INC	IX
	LD	B,0
	PUSH	IY
	POP	HL
	ADD	HL,BC
	LD	L,(HL)
	LD	H,B
	CALL	HLDEC
	LD	A,(IX)
	CP	0FFH
	JP	Z,RESET
	LD	A,(IX-1)	; get pdrive byte number
	CP	0		; if after DDGA:
	LD	A,13		; print a newline
	JR	Z,PDRIVE4
	LD	A,','		; else a comma
PDRIVE4	CALL	OUTCH
	JR	PDRIVE2

	END	ENTRY

